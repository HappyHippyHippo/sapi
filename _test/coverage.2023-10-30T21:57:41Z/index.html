
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sapi: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/happyhippyhippo/sapi/envelope.go (100.0%)</option>
				
				<option value="file1">github.com/happyhippyhippo/sapi/errors.go (100.0%)</option>
				
				<option value="file2">github.com/happyhippyhippo/sapi/validation.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package sapi

import (
        "encoding/xml"
        "fmt"
        "strconv"
        "strings"
)

// ----------------------------------------------------------------------------
// envelope status error
// ----------------------------------------------------------------------------

// EnvelopeStatusError defines the structure to manipulate an error structure
// that hold the information of an execution error and be assigned to the
// response status error list.
type EnvelopeStatusError struct {
        Service  int    `json:"-" xml:"-"`
        Endpoint int    `json:"-" xml:"-"`
        Param    int    `json:"-" xml:"-"`
        Error    string `json:"-" xml:"-"`
        Code     string `json:"code" xml:"code"`
        Message  string `json:"message" xml:"message"`
}

// NewEnvelopeStatusError instantiates a new error instance.
func NewEnvelopeStatusError(
        e any,
        msg string,
) *EnvelopeStatusError <span class="cov8" title="43">{
        return (&amp;EnvelopeStatusError{
                Error:   fmt.Sprintf("%v", e),
                Message: msg,
        }).compose()
}</span>

// SetService assigns a service code value to the error.
func (e *EnvelopeStatusError) SetService(
        val int,
) *EnvelopeStatusError <span class="cov6" title="15">{
        e.Service = val
        return e.compose()
}</span>

// SetEndpoint assigns an endpoint code value to the error.
func (e *EnvelopeStatusError) SetEndpoint(
        val int,
) *EnvelopeStatusError <span class="cov6" title="15">{
        e.Endpoint = val
        return e.compose()
}</span>

// SetParam assigns a parameter code value to the error.
func (e *EnvelopeStatusError) SetParam(
        param int,
) *EnvelopeStatusError <span class="cov5" title="10">{
        e.Param = param
        return e.compose()
}</span>

// SetError assigns a error code value to the error.
func (e *EnvelopeStatusError) SetError(
        err any,
) *EnvelopeStatusError <span class="cov4" title="6">{
        e.Error = fmt.Sprintf("%v", err)
        return e.compose()
}</span>

// SetMessage assigns a message to the error.
func (e *EnvelopeStatusError) SetMessage(
        msg string,
) *EnvelopeStatusError <span class="cov1" title="1">{
        e.Message = msg
        return e
}</span>

// GetCode retrieves the composed code of the error
func (e *EnvelopeStatusError) GetCode() string <span class="cov4" title="5">{
        return e.Code
}</span>

// GetMessage retrieves the message associated to the error
func (e *EnvelopeStatusError) GetMessage() string <span class="cov4" title="5">{
        return e.Message
}</span>

func (e *EnvelopeStatusError) compose() *EnvelopeStatusError <span class="cov10" title="89">{
        cb := strings.Builder{}
        // compose the service section of the code
        if e.Service != 0 </span><span class="cov7" title="30">{
                cb.WriteString(fmt.Sprintf("s:%d", e.Service))
        }</span>
        // compose the endpoint section of the code
        <span class="cov10" title="89">if e.Endpoint != 0 </span><span class="cov7" title="22">{
                if cb.Len() != 0 </span><span class="cov6" title="15">{
                        cb.WriteString(".")
                }</span>
                <span class="cov7" title="22">cb.WriteString(fmt.Sprintf("e:%d", e.Endpoint))</span>
        }
        // compose the param section of the code
        <span class="cov10" title="89">if e.Param != 0 </span><span class="cov5" title="10">{
                if cb.Len() != 0 </span><span class="cov4" title="6">{
                        cb.WriteString(".")
                }</span>
                <span class="cov5" title="10">cb.WriteString(fmt.Sprintf("p:%d", e.Param))</span>
        }
        // compose the error section of the code
        <span class="cov10" title="89">if e.Error != "" </span><span class="cov10" title="89">{
                if cb.Len() != 0 </span><span class="cov8" title="41">{
                        cb.WriteString(".")
                }</span>

                <span class="cov10" title="89">if i, err := strconv.Atoi(e.Error); err != nil </span><span class="cov3" title="4">{
                        cb.WriteString(e.Error)
                }</span> else<span class="cov9" title="85"> {
                        cb.WriteString(fmt.Sprintf("c:%d", i))
                }</span>
        }
        // assign the written code string to the error code structure parameter
        <span class="cov10" title="89">e.Code = cb.String()
        return e</span>
}

// ----------------------------------------------------------------------------
// envelope status error list
// ----------------------------------------------------------------------------

// EnvelopeStatusErrorList defines a type of data  that holds a list
// of error structures.
type EnvelopeStatusErrorList []*EnvelopeStatusError

// MarshalXML serialize the error list into a xml string
func (s EnvelopeStatusErrorList) MarshalXML(
        e *xml.Encoder,
        start xml.StartElement,
) error <span class="cov3" title="3">{
        // encode the list starting tag
        _ = e.EncodeToken(start)
        // iterate through all the stored error
        for _, v := range s </span><span class="cov3" title="4">{
                // create the iterated error starting tag name
                name := xml.Name{Space: "", Local: "error"}
                // encode the error instance tag with the code and message attributes
                _ = e.EncodeToken(xml.StartElement{
                        Name: name,
                        Attr: []xml.Attr{
                                {Name: xml.Name{Local: "code"}, Value: v.Code},
                                {Name: xml.Name{Local: "message"}, Value: v.Message},
                        },
                })
                // encode the terminating error tag
                _ = e.EncodeToken(xml.EndElement{Name: name})
        }</span>
        // encode the terminating list tag
        <span class="cov3" title="3">_ = e.EncodeToken(xml.EndElement{Name: start.Name})
        _ = e.Flush()
        return nil</span>
}

// ----------------------------------------------------------------------------
// envelope status
// ----------------------------------------------------------------------------

// EnvelopeStatus defines the structure to manipulate a
// response status information structure.
type EnvelopeStatus struct {
        Success bool                    `json:"success" xml:"success"`
        Errors  EnvelopeStatusErrorList `json:"error" xml:"error"`
}

// NewEnvelopeStatus instantiates a new request result status structure.
func NewEnvelopeStatus() *EnvelopeStatus <span class="cov7" title="24">{
        return &amp;EnvelopeStatus{
                Success: true,
                Errors:  EnvelopeStatusErrorList{},
        }
}</span>

// AddError append a new error to the status error list
func (s *EnvelopeStatus) AddError(
        e *EnvelopeStatusError,
) *EnvelopeStatus <span class="cov7" title="26">{
        s.Success = false
        s.Errors = append(s.Errors, e)
        return s
}</span>

// SetService assign a service code to all stored error.
func (s *EnvelopeStatus) SetService(
        val int,
) *EnvelopeStatus <span class="cov2" title="2">{
        for i := range s.Errors </span><span class="cov4" title="6">{
                s.Errors[i] = s.Errors[i].SetService(val)
        }</span>
        <span class="cov2" title="2">return s</span>
}

// SetEndpoint assign an endpoint code to all stored error.
func (s *EnvelopeStatus) SetEndpoint(
        val int,
) *EnvelopeStatus <span class="cov3" title="4">{
        for i := range s.Errors </span><span class="cov4" title="6">{
                s.Errors[i] = s.Errors[i].SetEndpoint(val)
        }</span>
        <span class="cov3" title="4">return s</span>
}

// ----------------------------------------------------------------------------
// envelope list report
// ----------------------------------------------------------------------------

// EnvelopeListReport defines the structure of a response list report
// containing all the request information, but also the total amount of
// filtering records and links for the previous and next pages
type EnvelopeListReport struct {
        Search string `json:"search" xml:"search"`
        Start  uint   `json:"start" xml:"start"`
        Count  uint   `json:"count" xml:"count"`
        Total  uint   `json:"total" xml:"total"`
        Prev   string `json:"prev" xml:"prev"`
        Next   string `json:"next" xml:"next"`
}

// NewEnvelopeListReport instantiates a new response list report by
// populating the prev and next link information regarding the given
// filtering information
func NewEnvelopeListReport(
        search string,
        start,
        count,
        total uint,
) *EnvelopeListReport <span class="cov5" title="10">{
        // store the prev URL query parameters if the start value
        // is greater than zero
        prev := ""
        if start &gt; 0 </span><span class="cov5" title="9">{
                // discover the previous page starting value
                nstart := uint(0)
                if count &lt; start </span><span class="cov3" title="4">{
                        nstart = start - count
                }</span>
                // compose the URL prev page query parameters
                <span class="cov5" title="9">prev = fmt.Sprintf(
                        "?search=%s&amp;start=%d&amp;count=%d",
                        search,
                        nstart,
                        count,
                )</span>
        }
        // store the next URL query parameters if the total number of
        // record are greater than the current start plus the number of
        // presented records
        <span class="cov5" title="10">next := ""
        if start+count &lt; total </span><span class="cov4" title="7">{
                // compose the URL next page query parameters
                next = fmt.Sprintf(
                        "?search=%s&amp;start=%d&amp;count=%d",
                        search,
                        start+count,
                        count,
                )
        }</span>
        // return the list report instance reference
        <span class="cov5" title="10">return &amp;EnvelopeListReport{
                Search: search,
                Start:  start,
                Count:  count,
                Total:  total,
                Prev:   prev,
                Next:   next,
        }</span>
}

// ----------------------------------------------------------------------------
// envelope
// ----------------------------------------------------------------------------

// Envelope identifies the structure of a response structured format.
type Envelope struct {
        XMLName    xml.Name            `json:"-" xml:"envelope"`
        StatusCode int                 `json:"-" xml:"-"`
        Status     *EnvelopeStatus     `json:"status" xml:"status"`
        ListReport *EnvelopeListReport `json:"report,omitempty" xml:"report,omitempty"`
        Data       interface{}         `json:"data,omitempty" xml:"data,omitempty"`
}

// NewEnvelope instantiates a new response data envelope structure
func NewEnvelope(
        statusCode int,
        data interface{},
        listReport ...*EnvelopeListReport,
) *Envelope <span class="cov6" title="19">{
        // initialize the envelope structure
        env := &amp;Envelope{
                StatusCode: statusCode,
                Status:     NewEnvelopeStatus(),
                ListReport: nil,
                Data:       data,
        }
        // assign the list report if given as argument
        if len(listReport) &gt; 0 &amp;&amp; listReport[0] != nil </span><span class="cov2" title="2">{
                env.ListReport = listReport[0]
        }</span>
        <span class="cov6" title="19">return env</span>
}

// GetStatusCode returned the stored enveloped response status code
func (s *Envelope) GetStatusCode() int <span class="cov1" title="1">{
        return s.StatusCode
}</span>

// SetService assign the service identifier to all stored error codes
func (s *Envelope) SetService(
        val int,
) *Envelope <span class="cov1" title="1">{
        s.Status = s.Status.SetService(val)
        return s
}</span>

// SetEndpoint assign the endpoint identifier to all stored error codes
func (s *Envelope) SetEndpoint(
        val int,
) *Envelope <span class="cov3" title="3">{
        s.Status = s.Status.SetEndpoint(val)
        return s
}</span>

// SetListReport assign the list report to the envelope
func (s *Envelope) SetListReport(
        listReport *EnvelopeListReport,
) *Envelope <span class="cov2" title="2">{
        s.ListReport = listReport
        return s
}</span>

// AddError add a new error to the response envelope instance
func (s *Envelope) AddError(
        e *EnvelopeStatusError,
) *Envelope <span class="cov6" title="16">{
        s.Status = s.Status.AddError(e)
        return s
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package sapi

import (
        "fmt"

        "github.com/happyhippyhippo/slate"
)

// ----------------------------------------------------------------------------
// errors
// ----------------------------------------------------------------------------

func errNilPointer(
        arg string,
        ctx ...map[string]interface{},
) error <span class="cov10" title="10">{
        return slate.NewErrorFrom(slate.ErrNilPointer, arg, ctx...)
}</span>

func errConversion(
        val interface{},
        t string,
        ctx ...map[string]interface{},
) error <span class="cov3" title="2">{
        return slate.NewErrorFrom(slate.ErrConversion, fmt.Sprintf("%v to %s", val, t), ctx...)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package sapi

import (
        "fmt"
        "net/http"
        "reflect"
        "strconv"

        "github.com/go-playground/locales/en"
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        translations "github.com/go-playground/validator/v10/translations/en"
        "github.com/happyhippyhippo/slate"
)

// ----------------------------------------------------------------------------
// defs
// ----------------------------------------------------------------------------

const (
        // ValidationContainerID defines the id to be used
        // as the container registration id of a validation.
        ValidationContainerID = slate.ContainerID + ".validation"

        // ValidationTranslatorContainerID defines the id to be used
        // as the container registration id of a translator.
        ValidationTranslatorContainerID = ValidationContainerID + ".translator"

        // ValidationUniversalTranslatorContainerID defines the id to be used
        // as the container registration id of a universal translator.
        ValidationUniversalTranslatorContainerID = ValidationContainerID + ".universal"

        // ValidationParserContainerID defines the id to be used
        // as the container registration id of an error parser instance.
        ValidationParserContainerID = ValidationContainerID + ".parser"

        // ValidationEnvID defines the validation module base environment variable name.
        ValidationEnvID = slate.EnvID + "_VALIDATION"
)

var (
        // ValidationLocale defines the default locale string to be used when
        // instantiating the translator.
        ValidationLocale = slate.EnvString(ValidationEnvID+"_LOCALE", "en")
)

// ----------------------------------------------------------------------------
// errors
// ----------------------------------------------------------------------------

var (
        // ErrValidationTranslatorNotFound defines an error that denotes
        // that a required error translator was not found.
        ErrValidationTranslatorNotFound = fmt.Errorf("validation translator not found")
)

func errValidationTranslatorNotFound(
        translator string,
        ctx ...map[string]interface{},
) error <span class="cov4" title="3">{
        return slate.NewErrorFrom(ErrValidationTranslatorNotFound, translator, ctx...)
}</span>

// ----------------------------------------------------------------------------
// validation universal translator
// ----------------------------------------------------------------------------

// NewValidationUniversalTranslator @todo doc
func NewValidationUniversalTranslator() *ut.UniversalTranslator <span class="cov6" title="7">{
        lang := en.New()
        return ut.New(lang, lang)
}</span>

// ----------------------------------------------------------------------------
// validation translator
// ----------------------------------------------------------------------------

// NewValidationTranslator @todo doc
func NewValidationTranslator(
        universalTranslator *ut.UniversalTranslator,
) (ut.Translator, error) <span class="cov5" title="5">{
        translator, found := universalTranslator.GetTranslator(ValidationLocale)
        if found == false </span><span class="cov1" title="1">{
                return nil, errValidationTranslatorNotFound(ValidationLocale)
        }</span>
        <span class="cov5" title="4">return translator, nil</span>
}

// ----------------------------------------------------------------------------
// validation parser
// ----------------------------------------------------------------------------

// ValidationParser @todo doc
type ValidationParser struct {
        mapper     map[string]int
        translator ut.Translator
}

// NewValidationParser instantiate a new validation parser instance
func NewValidationParser(
        translator ut.Translator,
) (*ValidationParser, error) <span class="cov10" title="19">{
        if translator == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("translator")
        }</span>

        <span class="cov9" title="18">return &amp;ValidationParser{
                mapper: map[string]int{
                        "eqcsfield":     1,
                        "eqfield":       2,
                        "fieldcontains": 3,
                        "fieldexcludes": 4,
                        "gtcsfield":     5,
                        "gtecsfield":    6,
                        "gtefield":      7,
                        "gtfield":       8,
                        "ltcsfield":     9,
                        "ltecsfield":    10,
                        "ltefield":      11,
                        "ltfield":       12,
                        "necsfield":     13,
                        "nefield":       14,

                        "cidr":             15,
                        "cidrv4":           16,
                        "cidrv6":           17,
                        "datauri":          18,
                        "fqdn":             19,
                        "hostname":         20,
                        "hostname_port":    21,
                        "hostname_rfc1123": 22,
                        "ip":               23,
                        "ip4_addr":         24,
                        "ip6_addr":         25,
                        "ip_addr":          26,
                        "ipv4":             27,
                        "ipv6":             28,
                        "mac":              29,
                        "tcp4_addr":        30,
                        "tcp6_addr":        31,
                        "tcp_addr":         32,
                        "udp4_addr":        33,
                        "udp6_addr":        34,
                        "udp_addr":         35,
                        "unix_addr":        36,
                        "uri":              37,
                        "url":              38,
                        "url_encoded":      39,
                        "urn_rfc2141":      40,

                        "alpha":           41,
                        "alphanum":        42,
                        "alphanumunicode": 43,
                        "alphaunicode":    44,
                        "ascii":           45,
                        "contains":        46,
                        "containsany":     47,
                        "containsrune":    48,
                        "endswith":        49,
                        "lowercase":       50,
                        "multibyte":       51,
                        "number":          52,
                        "numeric":         53,
                        "printascii":      54,
                        "startswith":      55,
                        "uppercase":       56,

                        "base64":          57,
                        "base64url":       58,
                        "btc_addr":        59,
                        "btc_addr_bech32": 60,
                        "datetime":        61,
                        "e164":            62,
                        "email":           63,
                        "eth_addr":        64,
                        "hexadecimal":     65,
                        "hexcolor":        66,
                        "hsl":             67,
                        "hsla":            68,
                        "html":            69,
                        "html_encoded":    70,
                        "isbn":            71,
                        "isbn10":          72,
                        "isbn13":          73,
                        "json":            74,
                        "latitude":        75,
                        "longitude":       76,
                        "rgb":             77,
                        "rgba":            78,
                        "ssn":             79,
                        "uuid":            80,
                        "uuid3":           81,
                        "uuid3_rfc4122":   82,
                        "uuid4":           83,
                        "uuid4_rfc4122":   84,
                        "uuid5":           85,
                        "uuid5_rfc4122":   86,
                        "uuid_rfc4122":    87,

                        "eq":  88,
                        "gt":  89,
                        "gte": 90,
                        "lt":  91,
                        "lte": 92,
                        "ne":  93,

                        "dir":                  94,
                        "excludes":             95,
                        "excludesall":          96,
                        "excludesrune":         97,
                        "file":                 98,
                        "isdefault":            99,
                        "len":                  100,
                        "max":                  101,
                        "min":                  102,
                        "oneof":                103,
                        "required":             104,
                        "required_if":          105,
                        "required_unless":      106,
                        "required_with":        107,
                        "required_with_all":    108,
                        "required_without":     109,
                        "required_without_all": 110,
                        "excluded_with":        111,
                        "excluded_with_all":    112,
                        "excluded_without":     113,
                        "excluded_without_all": 114,
                        "unique":               115,
                },
                translator: translator,
        }, nil</span>
}

// Parse method that will convert the list of validation error into
// an envelope struct to be used as the endpoint response.
func (p *ValidationParser) Parse(
        val interface{},
        errs validator.ValidationErrors,
) (*Envelope, error) <span class="cov8" title="11">{
        if val == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("value")
        }</span>

        <span class="cov8" title="10">if errs == nil || len(errs) == 0 </span><span class="cov3" title="2">{
                return nil, nil
        }</span>

        <span class="cov7" title="8">resp := NewEnvelope(http.StatusBadRequest, nil, nil)
        for _, err := range errs </span><span class="cov7" title="8">{
                parsed, e := p.convert(val, err)
                if e != nil </span><span class="cov4" title="3">{
                        return nil, e
                }</span>
                <span class="cov5" title="5">resp = resp.AddError(parsed)</span>
        }

        <span class="cov5" title="5">return resp, nil</span>
}

// AddError will add a validation mapped error to code value.
func (p *ValidationParser) AddError(
        e string,
        code int,
) <span class="cov1" title="1">{
        p.mapper[e] = code
}</span>

func (p *ValidationParser) convert(
        value interface{},
        e validator.FieldError,
) (*EnvelopeStatusError, error) <span class="cov7" title="8">{
        if e == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("error")
        }</span>

        <span class="cov6" title="7">typeof := reflect.TypeOf(value)
        field, _ := typeof.FieldByName(e.StructField())
        iparam := 0
        if param, ok := field.Tag.Lookup("vparam"); ok </span><span class="cov5" title="4">{
                var err error
                if iparam, err = strconv.Atoi(param); err != nil </span><span class="cov3" title="2">{
                        return nil, err
                }</span>
        }

        <span class="cov5" title="5">return NewEnvelopeStatusError(p.mapper[e.Tag()], e.Translate(p.translator)).SetParam(iparam), nil</span>
}

// ----------------------------------------------------------------------------
// validator
// ----------------------------------------------------------------------------

// Validator is a function type used to define a calling interface of
// function responsible to validate an instance of a structure and return
// an initialized response envelope with the founded error
type Validator func(val interface{}) (*Envelope, error)

// NewValidator instantiates a new validation function
func NewValidator(
        translator ut.Translator,
        parser *ValidationParser,
) (Validator, error) <span class="cov7" title="8">{
        // check validate argument reference
        if translator == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("translator")
        }</span>
        // check parser argument reference
        <span class="cov6" title="7">if parser == nil </span><span class="cov1" title="1">{
                return nil, errNilPointer("parser")
        }</span>
        // register the translator in the used validator
        <span class="cov6" title="6">validate := validator.New()
        _ = translations.RegisterDefaultTranslations(validate, translator)
        // return the validation method instance
        return func(value interface{}) (*Envelope, error) </span><span class="cov5" title="4">{
                // check the value argument reference
                if value == nil </span><span class="cov1" title="1">{
                        return nil, errNilPointer("value")
                }</span>
                // validate the given structure
                <span class="cov4" title="3">if errs := validate.Struct(value); errs != nil </span><span class="cov3" title="2">{
                        // compose the response envelope with the parsed validation error
                        return parser.Parse(value, errs.(validator.ValidationErrors))
                }</span>
                <span class="cov1" title="1">return nil, nil</span>
        }, nil
}

// ----------------------------------------------------------------------------
// validation service register
// ----------------------------------------------------------------------------

// ValidationServiceRegister @todo doc
type ValidationServiceRegister struct {
        slate.ServiceRegister
}

var _ slate.ServiceProvider = &amp;ValidationServiceRegister{}

// NewValidationServiceRegister will generate a new registry instance
func NewValidationServiceRegister(
        app ...*slate.App,
) *ValidationServiceRegister <span class="cov7" title="8">{
        return &amp;ValidationServiceRegister{
                ServiceRegister: *slate.NewServiceRegister(app...),
        }
}</span>

// Provide will register the validation package instances in the
// application container
func (sr ValidationServiceRegister) Provide(
        container *slate.ServiceContainer,
) error <span class="cov6" title="6">{
        // check container argument reference
        if container == nil </span><span class="cov1" title="1">{
                return errNilPointer("container")
        }</span>
        <span class="cov5" title="5">_ = container.Add(ValidationUniversalTranslatorContainerID, NewValidationUniversalTranslator)
        _ = container.Add(ValidationTranslatorContainerID, NewValidationTranslator)
        _ = container.Add(ValidationParserContainerID, NewValidationParser)
        _ = container.Add(ValidationContainerID, NewValidator)
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
